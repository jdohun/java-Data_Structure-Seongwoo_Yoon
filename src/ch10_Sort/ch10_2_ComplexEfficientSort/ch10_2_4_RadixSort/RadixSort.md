# 1. 기수 정렬: 특징과 적용 범위

- 정렬순서의 앞섬, 뒷섬을 비교하지 않는다. = 비교 자체를 수행하지 않는다.
- 정렬 알고리즘의 한계로 알려진 O(n log n)을 뛰어 넘을 수 있다.
    - 이론적으로 Quick 정렬보다 빠를 수 있다.
- 적용할 수 있는 대상이 매우 제한적이다. `길이가 동일한` 데이터들의 정렬에 용이하다.

## ex)

### 기수 정렬 OK

- "배열에 저장된 1, 7, 9, 5, 2, 6을 오름차순으로 정렬하라!"
- "영단어 red, why, zoo, box를 사전 편찬 순서대로 정렬하여라"

### 기수 정렬 NO

#### 기수 정렬이 가능하게 가공을 하면 가능하지만 그렇다면 기수 정렬을 통해 얻는 속도 이점보다 가공을 통한 속도 손해가 더 크기 떄문이다.

- "배열에 저장된 21, -9, 125, 8, -136, 45을 오름차순으로 정렬하라!"
- "영단어 professionalism, few, hydroxyproline, simple을 사전 편찬 순서대로 정렬하여라"

# 2. 기수 정렬: 정렬의 원리

- 기수(radix): 주어진 데이터를 구성하는 기본 요소(기호)
- 버킷(bucket): 기수의 수에 해당하는 만큼의 버킷을 활용한다.

## 기수정렬: LSD(List Significant Digit)

- LSD(중요도가 가장 낮은 자릿수값)를 시작으로 정렬
    - 중요도가 가장 높은 부분부터 시작해도 정렬되지 않는가?, 낮은 자리수 값부터 시작하는 이유?
      -> 중요도가 가장 낮은 자리를 제외한 나머지 부분이 모두 값이 똑같다면 어떻게 정렬 해야할까?

## 기수정렬: MSD(Most Significant Digit)

- MSD(중요도가 가장 높은 자릿수값)를 시작으로 정렬: LSD 와 반대
    - LSD와 방향성에서만 차이를 보이는가?
        - 그렇지 않다.
- 점진적으로 정렬이 완성되어 가는 방식이다.
  -> 따라서 중간중간에 정렬이 완료된 데이터는 더 이상의 정렬과정을 진행하지 않아야한다.
- 각 정렬의 차수마다 정렬할 구간을 나누어 진행해야한다.
  -> 각 차수의 정렬을 유지하기 위해서
  - 따라서 LSD 에 비해 추가적인 작업이 필요하기 때문에 잘 사용되지 않는다.